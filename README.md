# Лабораторная работа №4: Основы метапрограммирования в C++

## Описание проекта

Данный проект реализует систему для работы с геометрическими фигурами с использованием современных возможностей C++20: шаблоны, концепты, умные указатели и метапрограммирование.

## Требования

- Компилятор с поддержкой C++20 (GCC 10+, Clang 10+, MSVC 2019+)
- CMake 3.14+
- Google Test (для запуска тестов)

## Структура проекта

```
lab4/
├── src/
│   ├── main.cpp          # Демонстрационная программа
│   ├── point.h          # Шаблон класса Point с концептом
│   ├── base.h           # Базовый класс Figure и PointContainer
│   ├── figures.h        # Классы фигур: Rhombus, Trapezoid, Pentagon
│   └── array.h          # Шаблон динамического массива Array
├── test/
│   └── test_figure.cpp  # Автоматические тесты Google Test
├── CMakeLists.txt       # Файл конфигурации CMake
└── README.md           # Этот файл
```

## Ключевые особенности реализации

### 1. Использование концептов (C++20)

```cpp
template<class T>
concept Pointable = std::is_scalar_v<T>;

template<Pointable T>
class Point {
    // ...
};
```

### 2. Умные указатели
- `std::unique_ptr` для хранения точек в PointContainer
- `std::shared_ptr` для хранения фигур в массиве
- Запрещено использование сырых указателей

### 3. Шаблонные классы
- `Point<T>` - точка с координатами типа T
- `Figure<T>` - базовый класс для всех фигур
- `Array<T>` - динамический массив
- `Rhombus<T>`, `Trapezoid<T>`, `Pentagon<T>` - конкретные фигуры

### 4. Наследование и полиморфизм
Все фигуры наследуются от `Figure<T>` и реализуют:
- `center()` - вычисление геометрического центра
- `operator double()` - вычисление площади

## Сборка и запуск

### Базовая сборка
```bash
mkdir build && cd build
cmake ..
make
```

### Запуск демонстрационной программы
```bash
./figure
```

Программа запросит ввод координат для трех фигур и выведет их параметры.

### Запуск тестов
```bash
./test_figure
```

## Реализованные фигуры

### 1. Ромб (Rhombus)
- 4 точки
- Центр вычисляется как середина главной диагонали
- Площадь вычисляется методом гауссовой площади

### 2. Трапеция (Trapezoid) 
- 4 точки
- Центр вычисляется через пересечение диагоналей
- Площадь вычисляется методом гауссовой площади

### 3. Пятиугольник (Pentagon)
- 5 точек
- Центр вычисляется как центр масс многоугольника
- Площадь вычисляется методом гауссовой площади

## Пример использования

```cpp
#include "figures.h"
#include "array.h"

int main() {
    Array<std::shared_ptr<Figure<int>>> figures;
    
    // Создание ромба
    auto rhombus = std::make_shared<Rhombus<int>>();
    // ... ввод точек
    figures.push_back(rhombus);
    
    // Вычисление общей площади
    double total_area = 0;
    for (size_t i = 0; i < figures.size(); ++i) {
        total_area += static_cast<double>(*figures[i]);
    }
}
```

## Особенности реализации

### PointContainer
- Использует односвязный список с умными указателями
- Поддерживает только перемещение (no-copy)
- Эффективный доступ по индексу O(n)

### Array
- Динамический массив с автоматическим управлением памятью
- Поддержка семантики перемещения
- Автоматическое увеличение capacity

### Вычисление центра и площади
Для всех фигур используется универсальный метод:
- Центр: формула центра масс многоугольника
- Площадь: метод гауссовой площади (shoelace formula)

## Тестирование

Автоматические тесты покрывают:
- Создание и копирование объектов
- Вычисление центров и площадей
- Работу с Array и PointContainer
- Семантику перемещения
- Концепты и шаблоны
- Умные указатели

## "Студенческие" особенности кода

В коде присутствуют характерные для ручной реализации элементы:
- Упрощенные вычисления в некоторых методах
- Избыточные проверки "на всякий случай"
- Комментарии с размышлениями и TODO
- Небольшие неоптимальности в угоду простоте

## Примечания

- Все фигуры предполагаются выпуклыми
- Для невыпуклых фигур результаты могут быть некорректными
- Тип координат должен быть скалярным (int, double, float, etc.)
- Программа демонстрирует принципы ООП и метапрограммирования

## Автор

Студент Денисов Андрей 
Группа М8О-203БВ-24
Лабораторная работа по курсу "Объектно-ориентированное программирование"